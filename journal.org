# -*- mode: org; fill-column: 78; -*-
# Time-stamp: <2022-08-25 00:04:30 krylon>
#
#+TAGS: go(g) internals(i) ui(u) bug(b) feature(f)
#+TAGS: database(d) design(e), meditation(m)
#+TAGS: optimize(o) refactor(r) cleanup(c)
#+TODO: TODO(t)  RESEARCH(r) IMPLEMENT(i) TEST(e) | DONE(d) FAILED(f) CANCELLED(c)
#+TODO: MEDITATE(m) PLANNING(p) | SUSPENDED(s)
#+PRIORITIES: A G D
* Clock
  #+BEGIN: clocktable :scope file :maxlevel 200 :emphasize t
  #+CAPTION: Clock summary at [2022-08-25 Do 00:04]
  | Headline                                     | Time       |            |         |          |
  |----------------------------------------------+------------+------------+---------+----------|
  | *Total time*                                 | *5d 22:15* |            |         |          |
  |----------------------------------------------+------------+------------+---------+----------|
  | *Theseus [6/11]*                             | *5d 22:15* |            |         |          |
  | \_  /Components [4/10]/                      |            | /5d 17:19/ |         |          |
  | \_    Data types                             |            |            |    1:04 |          |
  | \_    Database                               |            |            |    2:38 |          |
  | \_    Networking [0/0]                       |            |            |    3:10 |          |
  | \_      mDNS [1/2]                           |            |            |         |     3:10 |
  | \_    Backend [3/3]                          |            |            |   23:54 |          |
  | \_      Testing                              |            |            |         |     0:35 |
  | \_      Notifications                        |            |            |         |    12:12 |
  | \_      HTTP API                             |            |            |         |     5:30 |
  | \_    Frontend [1/3]                         |            |            | 2d 8:04 |          |
  | \_      Filtering and Sorting                |            |            |         |     7:43 |
  | \_      Re-Arm a Reminder                    |            |            |         |     3:59 |
  | \_    Other sources [0/2]                    |            |            | 2d 2:29 |          |
  | \_      Framework?                           |            |            |         |     3:11 |
  | \_      logreader                            |            |            |         | 1d 23:18 |
  | \_  /Cleanup/                                |            | /1:28/     |         |          |
  | \_  /Testing [0/0]/                          |            | /1:30/     |         |          |
  | \_    Database                               |            |            |    1:30 |          |
  | \_  /Bugs/                                   |            | /1:58/     |         |          |
  | \_    Update timestamp when re-activating... |            |            |    1:16 |          |
  | \_    Deleting Reminders                     |            |            |    0:42 |          |
  #+END:
* Theseus [6/11]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :VISIBILITY: children
  :END:
** Components [4/10]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
*** Data types                                                    :internals:
    :LOGBOOK:
    CLOCK: [2022-07-01 Fr 17:48]--[2022-07-01 Fr 17:51] =>  0:03
    CLOCK: [2022-06-30 Do 22:10]--[2022-06-30 Do 23:11] =>  1:01
    :END:
*** Database                                                       :database:
    :LOGBOOK:
    CLOCK: [2022-07-01 Fr 17:51]--[2022-07-01 Fr 20:08] =>  2:17
    CLOCK: [2022-06-30 Do 23:11]--[2022-06-30 Do 23:32] =>  0:21
    :END:
    Pretty sure I'll use sqlite.
*** GUI                                                                  :ui:
    I /could/ use Gtk, or I could be adventurous and use fyne. I tried it
    before, and it did not work out well, but on the plus side, it is native
    Go, the cgo overhead would go away.

    But after taking a brief look at my fyne experiment, I'll stick with Gtk.
*** Networking [0/0]                                     :feature:meditation:
    I could make an attempt to build this as a distributed application so I
    can sync reminders between machines. I think that's a nice idea.
    A-and while we're at it, I would like using zeroconf/mDNS to have
    instances find each other.
**** TODO mDNS [1/2]
     :LOGBOOK:
     CLOCK: [2022-08-24 Mi 23:22]--[2022-08-25 Do 00:04] =>  0:42
     CLOCK: [2022-08-24 Mi 19:54]--[2022-08-24 Mi 22:22] =>  2:28
     :END:
     - [X] Publish
     - [ ] Discover
***** [2022-08-24 Mi 19:36]
      Well, looks like without Internet access I can forget about this. There
      is a Go package to talk DNS-SD, but I'd need to download the module. I
      could try and talk to avahi directly via dbus, but without an API
      reference, I don't think I'd get very far.
      [2022-08-24 Mi 19:53] - Nevermind, I just used my phone to access the
      Interwebs and download the zeroconf package, hoping it is not a dead
      end.
**** TODO Synchronization
*** Backend [3/3]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    :LOGBOOK:
    CLOCK: [2022-07-09 Sa 17:39]--[2022-07-09 Sa 17:40] =>  0:01
    CLOCK: [2022-07-04 Mo 17:12]--[2022-07-04 Mo 19:37] =>  2:25
    CLOCK: [2022-07-02 Sa 17:04]--[2022-07-02 Sa 19:06] =>  2:02
    CLOCK: [2022-07-01 Fr 20:56]--[2022-07-01 Fr 22:05] =>  1:09
    :END:
**** DONE Testing
     CLOSED: [2022-07-23 Sa 19:31]
     :LOGBOOK:
     CLOCK: [2022-07-23 Sa 19:22]--[2022-07-23 Sa 19:31] =>  0:09
     CLOCK: [2022-07-23 Sa 18:55]--[2022-07-23 Sa 19:21] =>  0:26
     :END:
     The notification displayed by the test "suite" does not expire.
     That was useful initially, but it got annoying surprisingly fast.
     ...
     Looking at the code, I have two options:
     - I can add a timeout parameter to the backend.notify method. It's called
       in only one place from the regular code, so I can add a parameter there.
     - I can add a timeout value to the Reminder struct *and* to the database.
     Sounds like an easy choice. Or is it?
**** DONE Notifications                                             :feature:
     CLOSED: [2022-07-23 Sa 19:33]
     :LOGBOOK:
     CLOCK: [2022-07-12 Di 20:42]--[2022-07-12 Di 23:22] =>  2:40
     CLOCK: [2022-07-11 Mo 20:46]--[2022-07-12 Di 01:03] =>  4:17
     CLOCK: [2022-07-09 Sa 17:40]--[2022-07-09 Sa 22:55] =>  5:15
     :END:
**** DONE HTTP API
     CLOSED: [2022-08-23 Di 19:04]
     :LOGBOOK:
     CLOCK: [2022-07-22 Fr 16:32]--[2022-07-22 Fr 17:50] =>  1:18
     CLOCK: [2022-07-06 Mi 18:27]--[2022-07-06 Mi 20:39] =>  2:12
     CLOCK: [2022-07-05 Di 19:38]--[2022-07-05 Di 21:38] =>  2:00
     :END:
     I decided to use HTTP as my application layer protocol, because it is
     simple and available, and it also leaves open the option to build a web
     based interface later on if I feel like it.
     But for the moment, the "client" is going to be the frontend, so I need
     to think about what operations I need.
     - [X] Add Reminder
     - [X] Delete Reminder
     - [X] Edit Reminder
     - [X] Get all Reminders
     - [X] Get pending Reminders
*** Frontend [1/3]                                                       :ui:
    :LOGBOOK:
    CLOCK: [2022-08-23 Di 19:05]--[2022-08-23 Di 20:18] =>  1:13
    CLOCK: [2022-07-20 Mi 19:40]--[2022-07-20 Mi 21:57] =>  2:17
    CLOCK: [2022-07-20 Mi 18:45]--[2022-07-20 Mi 19:20] =>  0:35
    CLOCK: [2022-07-19 Di 20:50]--[2022-07-20 Mi 14:25] => 17:35
    CLOCK: [2022-07-18 Mo 21:20]--[2022-07-19 Di 00:23] =>  3:03
    CLOCK: [2022-07-16 Sa 19:01]--[2022-07-16 Sa 20:25] =>  1:24
    CLOCK: [2022-07-15 Fr 20:05]--[2022-07-15 Fr 22:05] =>  2:00
    CLOCK: [2022-07-15 Fr 15:10]--[2022-07-15 Fr 17:44] =>  2:34
    CLOCK: [2022-07-14 Do 19:13]--[2022-07-14 Do 22:44] =>  3:31
    CLOCK: [2022-07-13 Mi 18:51]--[2022-07-13 Mi 21:30] =>  2:39
    CLOCK: [2022-07-09 Sa 17:05]--[2022-07-09 Sa 17:26] =>  0:21
    CLOCK: [2022-07-08 Fr 22:19]--[2022-07-08 Fr 23:26] =>  1:07
    CLOCK: [2022-07-08 Fr 18:42]--[2022-07-08 Fr 21:43] =>  3:01
    CLOCK: [2022-07-07 Do 22:38]--[2022-07-07 Do 22:50] =>  0:12
    CLOCK: [2022-07-07 Do 18:25]--[2022-07-07 Do 21:15] =>  2:50
    :END:
**** TODO Filtering and Sorting
     :LOGBOOK:
     CLOCK: [2022-08-23 Di 20:18]--[2022-08-23 Di 21:38] =>  1:20
     CLOCK: [2022-08-20 Sa 18:48]--[2022-08-20 Sa 22:10] =>  3:22
     CLOCK: [2022-08-20 Sa 15:45]--[2022-08-20 Sa 18:46] =>  3:01
     :END:
     I would like to filter and sort the Reminders in the TreeView, and Gtk
     supports that explicitly, but it makes matters a little more complicated,
     and I have no Internet access currently ([2022-08-20 Sa]), so I will have
     to experiment a little.
     ...
     After some toying around, I find the ListStore can - theoretically - do
     its own sorting, but it only sorta-kinda works, as I want to sort by more
     than one column, which seems to be too much for ListStore's or TreeView's
     little brain, even though I supply the logic. 
**** TODO Keyboard shortcuts
     I want to do more stuff with the keyboard.
     I am a very keyboard-centric person, so no surprise there, I guess.
     I have not done a whole lot of stuff with keyboard-events in ... pretty
     much any UI toolkit. But I suppose it is possible, ain't it?
     Unfortunately, to learn more about this, I would need access to the
     Internet, which I currently ([2022-07-20 Mi 23:11]) do not have, so this
     time I am not really procrastinating.
**** DONE Re-Arm a Reminder                                         :feature:
     CLOSED: [2022-07-22 Fr 14:12]
     :LOGBOOK:
     CLOCK: [2022-07-21 Do 17:11]--[2022-07-21 Do 20:17] =>  3:06
     CLOCK: [2022-07-20 Mi 23:12]--[2022-07-21 Do 00:05] =>  0:53
     :END:
     I want a way to conveniently re-arm a reminder
*** Other sources [0/2]                                             :feature:
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    The whole point of using a client-server approach was to allow external
    programs to supply Reminders, the way I used to do with my old -
    *ancient* - Perl POE Reminder application.
    Currently ([2022-07-25 Mo]), I am without usable Internet access, so I'll
    have to be a little creative to come up with ideas.
    I used to have one backend to watch directories for changes, mainly to be
    notified of finished Downloads. Without Internet access, that doesn't make
    a lot of sense.
    I've always wanted to monitor system logs for important messages. Now,
    *that* would be useful, wouldn't it?
**** TEST Framework?                                   :internals:meditation:
     :LOGBOOK:
     CLOCK: [2022-08-15 Mo 19:18]--[2022-08-15 Mo 21:19] =>  2:01
     CLOCK: [2022-08-15 Mo 13:27]--[2022-08-15 Mo 14:18] =>  0:51
     CLOCK: [2022-08-14 So 14:26]--[2022-08-14 So 14:45] =>  0:19
     :END:
     As I am staring in horror at an empty source file, I wonder if I should
     start by building a kind of framework for clients/sources. If I come up
     with several ideas for message sources, it would make sense to factor out
     as much of that as possible.
**** TODO logreader
     :LOGBOOK:
     CLOCK: [2022-08-18 Do 19:41]--[2022-08-18 Do 21:48] =>  2:07
     CLOCK: [2022-08-17 Mi 18:16]--[2022-08-17 Mi 19:35] =>  1:19
     CLOCK: [2022-08-16 Di 19:14]--[2022-08-16 Di 21:02] =>  1:48
     CLOCK: [2022-08-13 Sa 18:41]--[2022-08-13 Sa 20:44] =>  2:03
     CLOCK: [2022-07-27 Mi 03:31]--[2022-07-28 Do 19:19] => 39:48
     CLOCK: [2022-07-25 Mo 20:22]--[2022-07-25 Mo 20:35] =>  0:13
     :END:
     So lets read some log files, shall we?
     This should keep me busy for a while, too, I think, ... right?
** DONE Cleanup                                          :internals:refactor:
   CLOSED: [2022-07-24 So 11:39]
   :LOGBOOK:
   CLOCK: [2022-07-23 Sa 21:57]--[2022-07-23 Sa 22:11] =>  0:14
   CLOCK: [2022-07-22 Fr 21:27]--[2022-07-22 Fr 21:30] =>  0:03
   CLOCK: [2022-07-22 Fr 21:11]--[2022-07-22 Fr 21:20] =>  0:09
   CLOCK: [2022-07-22 Fr 18:35]--[2022-07-22 Fr 19:23] =>  0:48
   CLOCK: [2022-07-22 Fr 18:21]--[2022-07-22 Fr 18:35] =>  0:14
   :END:
** Testing [0/0]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
   Automated testing is good. So I would like to add more tests, and maybe,
   just /maybe/ play around with Go's builtin fuzzing.
*** Database
    :LOGBOOK:
    CLOCK: [2022-08-19 Fr 18:15]--[2022-08-19 Fr 19:45] =>  1:30
    :END:
** Bugs                                                                 :bug:
*** DONE Update timestamp when re-activating Reminders
    CLOSED: [2022-08-22 Mo 20:11]
    :LOGBOOK:
    CLOCK: [2022-08-22 Mo 18:55]--[2022-08-22 Mo 20:11] =>  1:16
    :END:
    When I reactivate a Reminder, I want its timestamp to be set to some point
    in the the not too distant future. Ideally, I could open a dialog to ask
    for a time.
*** DONE Deleting Reminders
    CLOSED: [2022-08-23 Di 18:47]
    :LOGBOOK:
    CLOCK: [2022-08-23 Di 18:28]--[2022-08-23 Di 18:47] =>  0:19
    CLOCK: [2022-08-22 Mo 20:12]--[2022-08-22 Mo 20:35] =>  0:23
    :END:
    When I try to delete a Reminder, a dialog appears and asks me if I am
    sure, but it only has one button that says /Yes/. ???
** Questions
